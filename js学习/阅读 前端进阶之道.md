# todo
## 闭包
### 何时使用： 变量既想反复使用，又想避免全局污染
+ "闭包：在爷爷的环境中执行了爸爸，爸爸中返回了孙子，本来爸爸被执行完了，爸爸的环境应该被清除掉，但是孙子引用了爸爸的环境，导致爸爸释放不了。这一坨就是闭包。简单来讲，闭包就是一个引用了父环境的对象，并且从父环境中返回到更高层的环境中的一个对象。"
~~~
function user () {
  var name = 'wangxi'
  return function getName () {
    return name
  }
}

//user()返回的是一个函数getName
var userName = user()() // userName 变量中始终保持着对 name 的引用
console.log(userName) // wangxi
userName = null // 销毁闭包，释放内存
~~~
+ "JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。" ——《JavaScript权威指南》
~~~
var name = 'Schopenhauer'
function getName () {
  console.log(name)
}

function myName () {
  var name = 'wangxi'
  getName()
}

myName() // Schopenhauer
~~~

# JS
## 内置类型
  1. null
  2. undefined
  3. boolean
  4. number
  5. string 
  6. symbol
  7. 对象  
      + 对象为引用类型 会有**深拷贝**和**浅拷贝**  
## typeof
  + 对于除了null意外都显示为 正确类型
    ~~~
    typeof null // 'object' 
    //一个古老的bug
    ~~~
  + 对于对象 除了函数都会显示object 
    ~~~
    typeof [] // 'object'
    typeof {} // 'object'
    typeof console.log // 'function'
    ~~~
## 四则运算符
  ~~~
  1 + '1' // '11'
  2 * '2' // 4
  [1, 2] + [2, 1] // '1,22,1'
  // [1, 2].toString() -> '1,2'
  // [2, 1].toString() -> '2,1'
  // '1,2' + '2,1' = '1,22,1'
  ~~~
  + 乘法运算符时 把string转num
  + 加法时 把number转string  
    
  * 特殊情况
  ~~~
  'a' + + 'b' // -> "aNaN"
  // 因为 + 'b' -> NaN
  // 你也许在一些代码中看到过 + '1' -> 1
  ~~~
## 原型
### 1. 普通对象 函数对象
> 凡是通过 **new Function()** 创建的对象都是函数对象，其他的都是普通对象。
~~~
var o1 = {}; 
var o2 =new Object();
var o3 = new f1();

function f1(){}; 
var f2 = function(){};
var f3 = new Function('str','console.log(str)');

console.log(typeof Object); //function 
console.log(typeof Function); //function  

console.log(typeof f1); //function 
console.log(typeof f2); //function 
console.log(typeof f3); //function   

console.log(typeof o1); //object 
console.log(typeof o2); //object 
console.log(typeof o3); //object
~~~
### 2. 构造函数 
> 实例的构造函数属性（constructor）指向构造函数。
~~~
var person1 = new Person('Zaxlct', 28, 'Software Engineer');
var person2 = new Person('Mick', 23, 'Doctor');

console.log(person1.constructor == Person); //true
console.log(person2.constructor == Person); //true
~~~
### 3. 原型对象
> 每个对象都有 \_\_proto__ 属性，但只有函数对象才有 **prototype** 属性
~~~
function Person() {}
Person.prototype.name = 'Zaxlct';
Person.prototype.age  = 28;
Person.prototype.job  = 'Software Engineer';
Person.prototype.sayName = function() {
  alert(this.name);
}
  
var person1 = new Person();
person1.sayName(); // 'Zaxlct'

var person2 = new Person();
person2.sayName(); // 'Zaxlct'

console.log(person1.sayName == person2.sayName); //true

// 原型对象
Person.prototype = {
   name:  'Zaxlct',
   age: 28,
   job: 'Software Engineer',
   sayName: function() {
     alert(this.name);
   }
}
~~~
> 在默认情况下，所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person）  

那么我们通过推导有
~~~
person1.constructor == Person  
Person.prototype.constructor == Person
~~~
> Person.prototype 也是Person 的实例。  
原型对象（Person.prototype）是 构造函数（Person）的一个实例。

~~~
 console.log(Person.prototype) //Person{}
 console.log(typeof Person.prototype) //Object
 console.log(typeof Function.prototype) // Function，这个特殊
 console.log(typeof Object.prototype) // Object
 console.log(typeof Function.prototype.prototype) //undefined
~~~
> Function.prototype 为什么是函数对象呢？
~~~
Function.prototype = new Function()
~~~
### 4. \_\_proto__
> JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做__proto__ 的内置属性，用于指向创建它的构造函数的原型对象。
~~~
Person.prototype.constructor == Person;
person1.__proto__ == Person.prototype;
person1.constructor == Person;J
~~~
### 5. 构造器
~~~
var obj = {}
// 等同于
var obj = new Object()
// obj 为 Object的一个实例 所以
obj.constructor === Object
obj.__proto__ === Object.prototype
~~~
### 6. 原型链
1. person1.\_\_proto__ 是什么？
2. Person.\_\_proto__ 是什么？
3. Person.prototype.\_\_proto__ 是什么？
4. Object.\_\_proto__ 是什么？
5. Object.prototype.\_\_proto__ 是什么？
+ [答案](https://www.jianshu.com/p/652991a67186)
1. Person.prototype
2. Function.prototype Person是一个由function生成的函数对象
3. Person.prototype 是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。因为一个普通对象的构造函数 === Object,所以 Person.prototype.\_\_proto__ === Object.prototype
4. 同2
5. Object.prototype 对象也有proto属性，但它比较特殊，为 null 。因为 null 处于原型链的顶端，这个只能记住。Object.prototype.\_\_proto__ === null
### 7.函数对象
> 所有函数对象的\_\_proto__都指向Function.prototype，它是一个空函数（Empty function）
#### js 内置构造器
+ number boolean String Object Function Array RegExp Err Date  
以上构造器的\_\_proto__ 均指向 Function.prototype  
+ Global不能直接访问
+ Arguments仅在函数调用时由JS引擎创建
+ Math，JSON是以对象形式存在的，无需new。它们的\_\_proto__是Object.prototype

> 所有的构造器都来自于 Function.prototype  
~~~
//函数为一等公民与众不同
Function.prototype.__proto__ === Object.prototype

Object.prototype.__proto__ === null // true
~~~
### new //优先级todo