# todo
## 闭包
### 何时使用： 变量既想反复使用，又想避免全局污染
+ "闭包：在爷爷的环境中执行了爸爸，爸爸中返回了孙子，本来爸爸被执行完了，爸爸的环境应该被清除掉，但是孙子引用了爸爸的环境，导致爸爸释放不了。这一坨就是闭包。简单来讲，闭包就是一个引用了父环境的对象，并且从父环境中返回到更高层的环境中的一个对象。"
~~~
function user () {
  var name = 'wangxi'
  return function getName () {
    return name
  }
}

//user()返回的是一个函数getName
var userName = user()() // userName 变量中始终保持着对 name 的引用
console.log(userName) // wangxi
userName = null // 销毁闭包，释放内存
~~~
+ "JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。" ——《JavaScript权威指南》
~~~
var name = 'Schopenhauer'
function getName () {
  console.log(name)
}

function myName () {
  var name = 'wangxi'
  getName()
}

myName() // Schopenhauer
~~~

# JS
## 内置类型
  1. null
  2. undefined
  3. boolean
  4. number
  5. string 
  6. symbol
  7. 对象  
      + 对象为引用类型 会有**深拷贝**和**浅拷贝**  
## typeof
  + 对于除了null意外都显示为 正确类型
    ~~~
    typeof null // 'object' 
    //一个古老的bug
    ~~~
  + 对于对象 除了函数都会显示object 
    ~~~
    typeof [] // 'object'
    typeof {} // 'object'
    typeof console.log // 'function'
    ~~~
## 四则运算符
  ~~~
  1 + '1' // '11'
  2 * '2' // 4
  [1, 2] + [2, 1] // '1,22,1'
  // [1, 2].toString() -> '1,2'
  // [2, 1].toString() -> '2,1'
  // '1,2' + '2,1' = '1,22,1'
  ~~~
  + 乘法运算符时 把string转num
  + 加法时 把number转string  
    
  * 特殊情况
  ~~~
  'a' + + 'b' // -> "aNaN"
  // 因为 + 'b' -> NaN
  // 你也许在一些代码中看到过 + '1' -> 1
  ~~~
## 原型
1. 普通对象 函数对象
~~~

~~~
## 