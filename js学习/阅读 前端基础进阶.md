[原文](https://www.jianshu.com/p/cd3fee40ef59)
 
## 内存空间
1. js的变量对象中有两类
    + 引用类型对象，存储**指向堆内存空间中的地址**
    + 非引用类型对象，直接存储值
2. JavaScript的内存生命周期
    ~~~
    // 1. 分配你所需要的内存
    // 2. 使用分配到的内存（读、写）
    // 3. 不需要时将其释放、归还

    var a = 20;  
    alert(a + 100);  
    a = null; 
    ~~~
    最常用的是通过**标记清除**的算法来找到哪些对象是不再继续使用的，因此a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。
3. JavaScript有自动垃圾收集机制  
  就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会**每隔固定的时间段**就执行一次释放操作。  
4. 为什么尽量少使用全局变量  
    在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量。
## 执行上下文
定义 每次当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为**当前代码的执行环境**，它会形成一个作用域。
+ 单线程
+ 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待
+ 全局上下文只有唯一的一个，它在浏览器关闭时出栈
+ 函数的执行上下文的个数没有限制
+ 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。
~~~
function f1(){
    var n=999;
    function f2(){
        alert(n);
    }
    return f2;
}
var result=f1();
result(); // 999

// f1中的函数f2在f1的可执行代码中，并没有被调用执行，因此执行f1时，f2不会创建新的上下文，而直到result执行时，才创建了一个新的
// 这里的result就是f2。
~~~
全局上下文入栈|f1 EC入栈|f1 EC出栈|result EC出栈|result EC入栈
:--:|:--:|:--:|:--:|:--:
-|-|-|-|-
-|f1 EC|-|result EC|-
global|global|global|global|global|

## [变量对象](https://www.jianshu.com/p/330b1505e41d)
当调用一个函数时，一个**新的执行上下文**就会被创建。
1. 一个执行上下文的生命周期可以分为两个阶段
    + 创建阶段 执行上下文会分别 
      1. 创建变量对象，
      2. 建立作用域链，
      3. 以及确定this的指向。
    + 代码执行阶段 会完成
      1. 变量赋值 
      2. 函数引用
      3. 执行其他代码。
2. 变量对象
    + 创建
      1. 建立arguments对象。检查当前上下文中的参数，建立该对象下的属 与属性值。

      2. 检查当前上下文的函数声明，也就是**使用function关键字**声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。

      3. 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，**为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改**。

      > JavaScript中，有两种声明方式，一个是使用var的**变量声明**，另一个是使用function的**函数声明**。

    + 未进入执行阶段之前，变量对象中的属性都不能访问
    + **变量对象**和**活动对象**其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。
    + 变量提升: 根据变量对象创建时的规则，变量属性中的函数优先级高于变量属性中的变量
3. 例子
    ~~~
    function test() {

        //因为不是function声明的所以只是一个普通变量而不是函数
        console.log(foo); //foo(){...}
        //根据变量提升 会先声明foo=undefined 再在下面一步赋值
        console.log(bar); //undefined

        // 根据 变量对象创建3 可知不会被第一个foo输出不为hello
        var foo = 'Hello';
        console.log(foo); //'Hello'

        // 相当于变量提升后的 对bar进行赋值为函数
        var bar = function () {
            return 'world';
        }
        console.log(bar); //bar(){...}

        function foo() {
            return 'hello';
        }
    }

    test();
    ~~~
    创建阶段
    ~~~
    //VO为变量对象
    VO = {
        arguments: {...},
        foo: <foo reference>,
        bar: undefined
    }
    // 这里有一个需要注意的地方，因为var声明的变量当遇到同名的属性时，会跳过而不会覆盖
    ~~~
    执行阶段
    ~~~
    VO -> AO
    VO = {
        arguments: {...},
        foo: 'Hello',
        bar: <bar reference>,
        this: Window
    }
    ~~~
4. 全局上下文的变量对象
    +  以浏览器中为例，全局对象为window。它的变量对象，就是window对象。this也指向window
    + 全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。

## 作用域链与闭包
在JavaScript中，我们可以将**作用域**定义为一套规则,这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。

闭包的使用
+ 函数柯里化
+ 模块
~~~
(function () {
    var a = 10;
    var b = 20;

    function add(num1, num2) {
        var num1 = !!num1 ? num1 : a;
        var num2 = !!num2 ? num2 : b;

        return num1 + num2;
    }

    window.add = add;
})();
// 前面部分相当于声明了一个函数并自动执行
add(10, 20);
~~~
setTimeout会有一个执行队列（先进先出），而这些操作进入队列的顺序，则由设定的延迟时间来决定。
~~~
setTimeout(function() {
	console.log(a);
}, 0);

var a = 10;

console.log(b);
console.log(fn);

var b = 20;

function fn() {
	setTimeout(function() {
			console.log('setTImeout 10ms.');
	}, 10);
}

fn.toString = function() {
	return 30;
}

console.log(fn);

setTimeout(function() {
	console.log('setTimeout 20ms.');
}, 20);

fn();

// 输出
// undefined
// [Function: fn]
// { [Function: fn] toString: [Function] }
// 10
// setTImeout 10ms.
// setTimeout 20ms.
~~~

利用闭包输出12345
~~~
for (var i=1; i<=5; i++) { 
 
    (function(i) {
        setTimeout( function timer() {
            console.log(i);
        }, i*1000 );
    })(i)
}
~~~
## this
原则：在一个函数上下文中，**this由调用者提供，由调用函数的方式来决定。**
1. 如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。
2. 如果函数独立调用，那么该函数内部的this，则指向undefined。
3. 在非严格模式中，当this指向undefined时，它会被自动指向全局对象。
#### 例子
~~~
var a = 20;
var foo = {
    a: 10,
    getA: function () {
        return this.a;
    }
}
console.log(foo.getA()); // 10

var test = foo.getA;
// 这里的test是指向foo.getA这个的一个引用，而test()属于函数独立调用
console.log(test());  // 20
~~~

~~~
function foo() {
    console.log(this.a)
}

function active(fn) {
    fn(); // 这个真实调用者，为独立调用，非严格模式下指向全局对象！！！
}

var a = 20;
var obj = {
    a: 10,
    getA: foo
}

active(obj.getA); // 20
~~~
## chrome 断点调试
## 函数式编程
1. 函数声明、函数表达式、匿名函数与自执行函数
	+ 函数声明
	+ 函数表达式
	+ 匿名函数  
		1. 函数自执行
			~~~
			(function() {
					// ...
			})();
			~~~
		2. 利用闭包形成模块
			~~~
			// 使用函数自执行的方式创建模块
			(function(window, undefined) {

					// 声明jQuery构造函数
					var jQuery = function(name) {

							// 主动在构造函数中，返回一个jQuery实例
							return new jQuery.fn.init(name);
					}

					// 添加原型方法
					jQuery.prototype = jQuery.fn = {
							constructor: jQuery,
							init:function() { ... },
							css: function() { ... }
					}
					jQuery.fn.init.prototype = jQuery.fn;

					// 将jQuery改名为$，并将引用保存在window上，形成闭包，对外开发jQuery构造函数，这样我们就可以访问所有挂载在jQuery原型上的方法了
					window.jQuery = window.$ = jQuery;
			})(window);

			// 在使用时，我们直接执行了构造函数，因为在jQuery的构造函数中通过一些手段，返回的是jQuery的实例，所以我们就不用再每次用的时候在自己new了
			$('#div1');
			~~~
