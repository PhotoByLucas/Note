[原文](https://www.jianshu.com/p/cd3fee40ef59)
 
## 内存空间
1. js的变量对象中有两类
    + 引用类型对象，存储**指向堆内存空间中的地址**
    + 非引用类型对象，直接存储值
2. JavaScript的内存生命周期
    ~~~
    // 1. 分配你所需要的内存
    // 2. 使用分配到的内存（读、写）
    // 3. 不需要时将其释放、归还

    var a = 20;  
    alert(a + 100);  
    a = null; 
    ~~~
    最常用的是通过**标记清除**的算法来找到哪些对象是不再继续使用的，因此a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。
3. JavaScript有自动垃圾收集机制  
  就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会**每隔固定的时间段**就执行一次释放操作。  
4. 为什么尽量少使用全局变量  
    在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量。
## 执行上下文
定义 每次当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。
+ 单线程
+ 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待
+ 全局上下文只有唯一的一个，它在浏览器关闭时出栈
+ 函数的执行上下文的个数没有限制
+ 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。
~~~
function f1(){
    var n=999;
    function f2(){
        alert(n);
    }
    return f2;
}
var result=f1();
result(); // 999

//f1中的函数f2在f1的可执行代码中，并没有被调用执行，因此执行f1时，f2不会创建新的上下文，而直到result执行时，才创建了一个新的，而这里的result就是f2。
~~~
全局上下文入栈|f1 EC入栈|f1 EC出栈|result EC出栈|result EC入栈
:--:|:--:|:--:|:--:|:--:
-|-|-|-|-
-|f1 EC|-|result EC|-
global|global|global|global|global|

## [变量对象](https://www.jianshu.com/p/330b1505e41d)
当调用一个函数时，一个**新的执行上下文**就会被创建。
1. 一个执行上下文的生命周期可以分为两个阶段
    + 创建阶段 执行上下文会分别 
      1. 创建变量对象，
      2. 建立作用域链，
      3. 以及确定this的指向。
    + 代码执行阶段 会完成
      1. 变量赋值 
      2. 函数引用
      3. 执行其他代码。
2. 变量对象
    + 创建
      1. 建立arguments对象。检查当前上下文中的参数，建立该对象下的属 与属性值。

      2. 检查当前上下文的函数声明，也就是**使用function关键字**声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。

      3. 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，**为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改**。
    + 未进入执行阶段之前，变量对象中的属性都不能访问
    + **变量对象**和**活动对象**其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。
    + 变量提升: 根据变量对象创建时的规则，变量属性中的函数优先级高于变量属性中的变量
3. 例子
    ~~~
    function test() {

        console.log(foo); //foo(){...}
        //因为不是function声明的所以只是一个普通变量而不是函数
        console.log(bar); //undefined

        // 根据 变量对象创建3 可知不会被第一个foo输出不为hello
        var foo = 'Hello';
        console.log(foo); //'Hello'

        var bar = function () {
            return 'world';
        }
        console.log(bar); //bar(){...}

        function foo() {
            return 'hello';
        }
    }

    test();
    ~~~
    创建阶段
    ~~~
    //VO为变量对象
    VO = {
        arguments: {...},
        foo: <foo reference>,
        bar: undefined
    }
    // 这里有一个需要注意的地方，因为var声明的变量当遇到同名的属性时，会跳过而不会覆盖
    ~~~
    执行阶段
    ~~~
    VO -> AO
    VO = {
        arguments: {...},
        foo: 'Hello',
        bar: <bar reference>,
        this: Window
    }
    ~~~
4. 全局上下文的变量对象
    +  以浏览器中为例，全局对象为window。它的变量对象，就是window对象。this也指向window
    + 全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。
