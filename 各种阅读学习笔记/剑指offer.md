3.  在二维数组中查找一个数字
4.  为字符串替换空格

    例子：将"hello world js !"中的空格替换为两个 0 -> "hello00world00js00!"

    O(n)步骤：

    1. 从头开始遍历字符串，确定其中空格的数量，并计算出最后要开辟的数组的长度
    2. 准备两个指针 P1(前)和 P2(后)，两个指针之间间隔的数量为 开辟的新数组长度-原来数组长度。
    3. 从最后开始遍历数组，

       - 在遇到空格之前，将每一个字都从前面的指针复制到后面的指针上
       - 在遇到空格时，P1 位置不变，在 P2 插入替换的字符串并将 P2 前移，直到 P1P2 重叠。

5.  从尾到头打印链表

    使用栈来存储链表的遍历 先进后出

6.  输入一棵树的前序和中序的结果，根据结果重建二叉树

    1. 取前序数组第一个(树的根节点)
    2. 遍历中序数组，找到前序数组的第一个，分出左右树
    3. 递归

7.  用两个栈(先进后出)实现队列(先进先出)

    - 入队：将元素进栈 stack1

    - 出队：判断栈 stack2 是否为空，
      - 如果为空，则将栈 stack1 中所有元素 pop，并 push 进栈 stack2，栈 stack2 出栈；
      - 如果不为空，栈 stack2 直接出栈。

8.  旋转数组的最小数字

    - 查找
      - 已排序/部分排序 ：二分查找
      - 哈希表
        - O(1)时间内查找到某一元素，效率最高
        - 需要额外空间
      - 二叉排序树查找 -> BST
    - 排序
    - 题目

      把一个数组最开始的若干个元素搬到数组的末尾，我们称之为**数组的旋转**。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。

      例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为 1。

    - O(log n)解决步骤

      1. 输入数组是部分有序的，可分为前后两段递增数组，且前段数组大于等于后段数组，故采用二分查找，在数组开始和结束分别设置两个指针 P1 和 P2
      2. 取中间的数字 tempNum，
         - 若 tempNum > P1，则说明中间的数组还在前段的递增数组中，故将 P1 移动到 tempNum 处
         - 反之，若 tempNum<= P1，则说明 tempNum 处于后段数组中，移动 P2 至 tempNum
      3. 继续执行知道 P1、P2 两个指针相邻

9.  斐波那契数列

    ```
        f(n) = f(n-1)+f(n-2)         (n>1)
            = 1                     (n=1)
            = 0                     (n=0)
    ```

    - 递归方法

    - O(n)解法

      ```
      function fbnc(n){
          if( n===1) return 0
          if (n===2) return 1

          if (n>2) {
              var num1=1 // 下一次循环中的较大数
              var num2=0 // 下一次循环中的较小数
              var fbncN=0
              for (let index = 2; index < n; index++) {
                  fbncN=num1+num2
                  num2=num1
                  num1=fbncN
              }
              return fbncN
          }
      }
      ```

10. 二进制中的 1 个数
    - 位运算
      - &与
      - |或
      - ^异或
      - n = n >> 1 右移


    - 题目

      给定一个数字，给出对应二进制中 1 的个数

    - 错误解法：位运算右移，但是会遇到负数陷入死循环

    - 正确解法
        ~~~
        function Num1(n) {
        var count = 0;

        // 加入一个flag属性，作为验证该数的某一位是否为1的依据
        // 二进制为  00000001
        var flag = 1;
        while (flag) {
            if (n & flag) {
            count++;
            }

            flag = flag << 1;
            // 会变为
            // 0000010
            // 0000100
            // 0001000
            // 知道超出32位
        }
        return count;
        }

        ~~~

    - 有x个1就O(x)的解法

        ~~~
        function Num1(n){
            var count=0
            while(n){
                count++

                // 1. 减法会使位运算中的数字中少去一个1
                // 2. 少去一个1的n与原来的n做且运算，前面有1的都会保留，不同的部分不回保留
                n=n & n-1
            }
            return count
        }
        ~~~

11. 数值的整数次方

    - 题目

    ```
    /**
    * @param {number} base 基数
    * @param {number} exponent 次方
    * @return {number} result = base^exponent
    */
    function Power(base,exponent){

    }
    ```

    - 坑点(边界问题)

      存在正数次方、负数次方、0 次方

    - O(n)

      ```
      for(let i=0;i<exponent;i++) {
          result*=base
      }
      ~~
      ```

    - O(log n)

      以 2 为例子，递归求 2^1,2^2,2^4,2^8...

12. 打印 1 到最大的 n 位数

    - 题目：输入 3，则打印 1,2,3,...999
    - 坑点：n 可能是超过位数的大数，应该使用字符串，在字符串上模拟加法
    - 解法

      ```
      // 打印的位数
      let tag =1
      let myNumber=new Array()
      for(let i=0;i<n+1;i++){
          // 新建一个n+1长度的初始化为0的数组
          myNumber.push(0)
      }

      while(tag){
          print(tag)
          increase(n)
      }

      // 增长函数 立刻执行
      // n 为+1的数组位
      function increase(n){
          // 最高一位为1时，说明已经超过n位
          if(myNumber[0]!==0){tag=false}

          myNumber[n]+=1
          if(myNumber[n]===10){
              // 进位
              increase(n-1)
              myNumber[n]=0
          }
      }

      function print(tag){
          let tempNum=myNumber.slice[n-tag+1,n]
          console.log(tempNum.join())
      }

      ```

13. O(1)删除链表节点
    - 题目：给定一个节点和一个链表，要求从链表中删除该节点
    - 注意：链表是否只有一个节点，即要将链表头指向空
    - 解法：
      - 遍历一遍后找到要删除的节点，按照常规方法删除 O(n)
      - O(1) 解法
        1. 直接将要删除的节点的下一个节点复制到要删除的节点中
        2. 移去下一个节点
14. 调整数组顺序使奇数位于偶数前面

    - 题目：给定一个数组，调整后使得奇数在前面偶数在后面
    - 双指针解法
      1. P1 指针在从前往后，指向偶数时停止
      2. P2 指针在从后往前，指向奇数时停止
      3. 交换两个指针直到相遇
    - 拓展：将分类的条件修改，如

      1. 使负数在非负数前
      2. 使能被 3 整除的放在不能的前面
      3. ...

      此时应该将判定条件封装为一个函数，return 真假作为判断

15. 链表中的倒数第 k 个节点
    - 解法：双指针
      1. P1 指向头部
      2. P2=P1+k
      3. 同时遍历一次，直到 P2 达到尾部，读 P1
16. 反转链表

    - 解法：三个指针

      ```
        // pPre,pNow,pAfter

        pNow.nextNode=pPre
        pPre=pNow
        pNow=pAfter
        pAfter=pAfter.nextNode
      ```

17. 合并两个排序的链表(连续拿出来排列)
18. 树的子结构(递归验证 b 树是否是 a 树字数)
19. 二叉树镜像(递归)
20. 顺时针打印矩阵(画图绕圈)
21. 包含 min 函数的栈(建立一个辅助栈)
22. 栈的压入、弹出序列

    - 例子

      压入序列：12345
      弹出序列：45321

    - 解法

      1. 压入第一个数字，判断是否为弹出序列中的第一个数字，否则则继续压入
      2. 判断到弹出序列数字与压入序列数字相同，则弹出该数字，重复 1

23. 从上到下打印二叉树

    - 题目
      ```
           1
        2     3
       4 5   6 7
      ```
      打印出 1234567
    - 解法：队列，使用递归会出错

      | 步骤 | 操作   | 队列    |
      | ---- | ------ | ------- |
      | 1    | 打印 1 | 2 3     |
      | 2    | 打印 2 | 3 4 5   |
      | 3    | 打印 3 | 4 5 6 7 |
      | 4    | 打印 4 | 5 6 7   |
      | 5    | 打印 5 | 6 7     |
      | 6    | 打印 6 | 7       |
      | 7    | 打印 7 |         |

24. 二叉搜索树后序列遍历

    - 题目：输入一个数组如，[5,7,6,9,11,10,8],判断是否为一个二叉树的后序遍历
    - 分析：二叉搜索树后序遍历最后一个为根节点，在前半段为左子树，均大于根节点，后半段为右子树
    - 解法

      ```
        // 函数用于确认输入数组是否是后续遍历
        function verify(array){
          // 根节点
          let rootNode=array[array.length]

          let i=0
          // 找到一个小于rootNode的临界点
          for

          // 在临界点右边应全部小于临界点
          for

          let left = true,right=true
          // 左子树不空
          if(i>0) left= verify(array.slice(0,i))

          if(i<array.length-1) right= verify(array.slice(i,length-1))

          return (left&&right)
        }
      ```

25. 二叉树中为某一值的路径

    - 题目：输入一个值 n，输出所有从树的根节点到另一个节点的路径上的值之和加起来等于该值的路径
    - 分析：前序遍历，其实是模拟了一个栈的压入压出过程，不断递归找

26. 复杂链表的复制

    - 题目

      复杂链表的节点中，有两个指针指向，分别指向下一个节点和另一个随机节点（也可能是 null）

      ```
        class Node {
          var nodeValue
          var nextNodePoint // 指向下一个链表结点的指针
          var complexNodePoint // 指向随机一个链表结点的指针
        }
      ```

    - 解法：

      - O(n^2)解法：遍历复制两次

        1. 复制 nextNodePoint
        2. 复制 complexNodePoint，复制的时候每一次定位一个节点都需要定位链表节点，每次定位需 O(n)

      - O(n)解法：建立一个 O(n) 的哈希表来存储 complexNodePonit 之间的映射关系，省去 complexNodePoint 的寻找过程

      - 不使用辅助空间的 O(n)：
        1. 在原来的链表上，对于每个节点 N 都复制一个复制 N'，并插入在原本的 N 后面
           ```
             A->B->C
             // 复制后变为
             A->A'->B->B'->C->C'
           ```
        2. 将所有 N'的节点中，complexNodePonit 的指向改为原本的 next 节点，即
           ```
             // 对随机指向的那个指针 complexNodePonit 假设有A->C 则有
             A'-> C
             // 直接next可以改为
             A' -> C'
           ```
        3. 将 N'节点从原来链表中抽离，即修改所有 N'节点的 NextNodePoint

27. 二叉搜索树与双向链表

    - 题目：将二叉搜索树转化为一颗排序的双向链表
    - 分析：中序遍历二叉树

28. 字符串的排列

    - 题目：给定如 abc 这样的 n 个字母，打印出 abc，acb，bac，bca，cab，cba
    - 解法：

      1. 锁定一个字母，求后面所有字母的排列
      2. 对 1 进行递归 p(str,strBegin)

> 解决复杂问题：画图，举例子，分解（分治法、动态规划）

29. 数组中出现次数超过一半的数字

    - 题目：未排序数组找出如题数字
    - 解法：

      - O(n log n) 排序后找
      - O(n)
        1. 从头开始遍历数组，存下 **数字** 和 **次数**
        2. 当遍历到相同的数字时，次数+1；否则则-1。当遍历到使次数变 0 的数字时，用该数字替代原来的数字
        3. 遍历到结束，最后的数字即为那个数

30. 最小 k 个数：输入一个数组，找出前 k 小的所有数字

    1. 基于 partition 函数（快排交换函数）的 O(n)  
       选取数组中的第 k 个数，然后按照快排那样左右换
    2. O(n logk)建立一颗节点数为 k 的树来储存选取的数字，遍历数组，修改树达到目的

31. 连续子数组最大和

    题目：从一个数组（有正数和负数）中选出一段连续的子数组，求子数组最大和，要求 O(n)

    1. O(n)累加求和（相当于一个基于 DP 的算法）

       1. 初始化 temp,biggest=0，
       2. 遍历数组，遇到正数，则存下来 temp+=num；遇到负数，temp=num
       3. 记下该比较取 biggest=max(biggest,temp)，
       4. 重复

    2. DP 递归式
       f(i) 为以第 i 位结尾的数字最大和
       ```
       f(i) = array[i] ( f(n-1)<0 )
            = f(n-1) + array[i]
       ```
       返回 max(f(1)~f(i))

32. [从 1 到 n 整数中 1 出现的次数](https://blog.csdn.net/yi_Afly/article/details/52012593)
    例子：514

    1. 计算个位为 1 的次数  
       只有每出现一次 0~9，十位数才会+1，则从 0~530 出现了 53 次，加上 531 中个位的 1，个位共出现了 53 x 1 + 1
    2. 计算十位的 1 的次数  
       每次 0~9，十位数+1，0~500 在十位数为 1 的时候，个位数可以是从 0~9，这个过程要循环 5 次，5 x 10，再加上百位为 5 的时候十位为 1 的个数：510~514，共五个，5 x 10 + 4 + 1
    3. 更高位 0\*100+100

    - 规则
      - 若 weight 为 0，则 1 出现次数为 round x base
      - 若 weight 为 1，则 1 出现次数为 round x base+former+1
      - 若 weight 大于 1，则 1 出现次数为 rount x base+base

33. [把数组排成最小的数](https://www.cnblogs.com/youxin/p/3294154.html)

    - 题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3,32,321}，则打印出这 3 个数字能排成的最小数字 321323。

    步骤

    1. 定义一套新的比较两个数大小规则

       对于两个数 m,n，将其拼成 mn 和 nm 的字符串（防止溢出），位数一定相同，若 mn>nm，则返回 n < m

    2. 按照 1 的规则对所有数字进行排序，排序后数组组成的数就最小

34. 丑数：输出第 n 个丑数，丑数为只能被 2、3、5 整除的数字，从 1 开始

    ```
    function GetUglyNumber_Solution(index) {
        if (index === 0) return 0;
        // 数组初始化为1
        var uglyNum = [1];

        // 建立对最小丑数乘数的索引
        var factor2 = 0,
            factor3 = 0,
            factor5 = 0;
        for (var i = 1; i < index; i++) {
            uglyNum[i] = Math.min(uglyNum[factor2] * 2, uglyNum[factor3] * 3, uglyNum[factor5] * 5);
            if (uglyNum[i] === uglyNum[factor2] * 2) factor2++;
            if (uglyNum[i] === uglyNum[factor3] * 3) factor3++;
            if (uglyNum[i] === uglyNum[factor5] * 5) factor5++;
        }
        return uglyNum[index - 1];
    }
    ```

35. 第一个只出现一次的字符：给一个字符串，找出第一个只出现一次的字符

    建立一个哈希表，遍历一次，求所有字母出现次数，再遍历一次边遍历边查找出现次数为 1 的第一个数

36. 数组中的逆序对

    - 例子：例如在数组{7,5,6,4}中，一共存在 5 个逆序对，分别是（7,6）、（7,5）、（7,4）、（6,4）和（5,4）。

    - 基于归并排序的 O(n log n)

      1. 所有数组分开，再开始两两合并，初始化 result=0
      2. 7，5 合并的时候，合并为 5，7，并将 result+=1，同理 64，得到[5,7],[4,6],result=2
      3. 再将这两个数组合并，一步步排列为[4567],result+=2,0,1,0

37. 两个链表的第一个公共节点

    - 题目：给定两个单向链表，找出其第一个公有节点
    - 分析：由于都是单向的，两段链表合在一起后不可能再岔开，只可能是个 Y 状的不可能是 X 状
    - 步骤
      1. 分别遍历两个链表，得到长度 m,n
      2. 若 m!=n，则长的链表先走 m-n 步，再开始同步遍历，之后得到第一个相同节点即为题目所求

38. 数字在排序数组中出现的次数

    - 分析：二分查找找出数组中的第一个和最后一个
      1. 找第一个，比较中间的数，若< k，则第一个数在后半段；若 >= k，则 k 在前半段，直到找到一个数前面不是 k 且这个数是 k
      2. 同理找最后一个，然后与 1 找出来的相减

39. 二叉树的深度

    - 求二叉树深度
      - 递归 f(n) = max(f(左),f(右))+1
        1. 若节点左子树为空，则等于右子树高度+1；同理左子树
        2. 若左右都不为空，则为其大者
    - 判定二叉树是否平衡

40. 数组中只出现一次的数字

    一个数组中除了两个数字 a,b 其他数字均出现了两次，找出该两个数字

    - 步骤
      1. 遍历一次所有数字取异或，相同的数字取异或将相互抵消为 0，最终值为 a^b
      2. a^b 中必定有一位为 1，取该位作为参考，在该位上或 a=0,b=1 或 a=1,b=0
      3. 再次遍历所有数字，假设 a=0，b=1，初始化 temp1=temp2=0
         - 对该位上为 1 的 num，temp1^=num
         - 对该位上为 0 的 num，temp0^=num  
           得出 temp1，0 就是那两个数（其他有相同的数字的 num 都抵消了）

41. 和为 s 的两个数字 VS 和为 s 的连续正数序列

    - 题目一：输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，输出任意一对即可。 例如输入数组{1、2、4、7、11、15}和数字 15。由于 4 ＋ 11 ＝ 15，因此输出 4 和 11。

      1. 头尾双指针p1 p2
      2. 若Array[p1]+Array[p2]>s,p2--;反之p1++，直到=s

    - 题目二：输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。例如输入15，由于1＋2＋3＋4＋5＝4＋5＋6＝7＋8＝15，所以结果打印出3个连续序列1～5、4～6和7～8。

      1. 新建p1=0，p2=1，temp=A[p1]+A[p2]
      2. 循环 直到p1==p2
          - temp < s, p2++,temp+= A[p2]
          - temp > s, p1++,temp+= A[p1]
          - temp = s, p2++,打印

42. 翻转单词顺序 VS左旋转字符串

43. 