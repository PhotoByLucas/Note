1. react 和 vue 都要写 key why？

   - diff 策略

     1. tree diff：Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。**只比较同一个层级**，当发现某一子节点不在了直接删除该节点以及其所有子节点，不会用于进一步的比较。
     2. component diff：拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。

        - 对于**非同一类的组件**，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。
        - 对**相同类型组件**，根据 Virtual DOM 是否变化也分两种，可以用**shouldComponentUpdate()**判断 Virtual DOM 是否发生了变化，若没有变化就不需要在进行 diff，这样可以节省大量时间，若变化了，就对相关节点进行 update

     3. element diff：对于同一层级的一组子节点，它们可以通过唯一 id 进行区分，并遵循1，2策略

    - 如果有key，则是通过map找；没有则是通过遍历找
    - 没有key的情况下可以对节点就地复用，只更新数据不更新节点，提高性能。

2. ['1', '2', '3'].map(parseInt) what & why ?
    - 两个函数的参数
        - map(value,index)
        - parseInt(string,base基数)
    ~~~
    parseInt('1', 0) // 1
    parseInt('2', 1) // NaN 基数[2,36]
    parseInt('3', 2) // NaN, 3 不是二进制

    ['10','10','10','10','10'].map(parseInt);
    // [10, NaN, 2, 3, 4]
    ~~~

3. 防抖 节流

    防抖动是将多次执行变为**最后一次执行**，节流是将多次执行变成**每隔一段时间执行**。

    - 防抖：你尽管触发事件，但是我**一定在事件触发 n 秒后才执行**，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就**以新的事件的时间为准**，n 秒后才执行
        ~~~
        const debounce = function(func=()=>{},wait=50){
            // 闭包
            var timer 

            return function(){
                // 清除之前的定时器
                if(timer) clearTimeout(timer)
                // 明确变量指向
                var self=this
                var args=arguments
                
                timer=setTimeout(()=>{
                    func.apply(self,args) // 将变量对象和this指定
                },wait)
            }
        }
        ~~~
        [带取消和立刻执行版本todo](https://github.com/mqyqingfeng/Blog/issues/22)

    - 节流：如果你持续触发事件，每隔一段时间，只执行一次事件。
        ~~~
        const throttle = function(func = () => {}, wait = 50) {
            var timer;
            var pre = 0;

            // 使用时间戳
            return function() {
                let self = this;
                let argc = arguments;
                let now = +new Date(); // 获取时间戳
                if (now - pre > wait) {
                    func.apply(self, argc);
                    pre = now;
                }
            };

            // 使用定时器
            return function() {
                var self = this;
                var argc = arguments;
                // 没有计时器的时候才执行
                if (!timer) {
                    setTimeout(() => {
                        func.apply(self, argc);
                        timer = null;
                    }, wait);
                }
            };
        };

        ~~~
        [更完整版](https://github.com/mqyqingfeng/Blog/issues/26)
4. 介绍下 Set、Map、WeakSet 和 WeakMap 
    - Set 
        - 只有键值，没有键名
        - 不能重复
        - 可以遍历，有has add delete size
        ~~~
        // 去除数组的重复成员
        [...new Set(array)]

        [...new Set('ababbc')].join('')
        // "abc"
        ~~~
    - WeakSet 与set类似
        - 成员只能是对象，而不能是其他类型的值。
        - WeakSet 中的对象都是弱引用
    - Map

        Object的键值只能是字符串，但是map可以是任意键值
        ~~~
        const map = new Map([
            ['name', '张三'],
            ['title', 'Author']
        ]);
        ~~~
    - weakMap
        - WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
        - WeakMap的键名所指向的对象，不计入垃圾回收机制。当该键值对象被清除时，weakMap里面值也会被清除

5. DFS BFS
    - DFS 使用栈
        ~~~
        let deepTraversal1 = (node, nodeList = []) => {
        if(node!==null){
            nodeList.push(node)
            let children=node.children
            for (let index = 0; index < children.length; index++) {
            deepTraversal1(children[index],nodeList)
            }
        }
        }

        // 非递归 应使用栈
        let deepTraversal3 = (node) => {
            let stack = []
            let nodesArray = []// node 执行的顺序
            // 不为空
            if (node) {
                stack.push(node)
                // 操作该node的代码
                while(stack.length){
                    let top = stack.pop()
                    // 执行顺序
                    nodesArray.push(top)
                    let children=top.children
                    for (let index = children.length-1; index >= 0; index--) {
                        const child = children[index];
                        // 压入栈
                        stack.push(child)
                    }
                }
            }
            return nodesArray
        }
        ~~~
    - BFS 使用队列
        ~~~
        // 改行进行改动就可
        stack.shift(node)
        ~~~
6. 请分别用深度优先思想和广度优先思想实现一个拷贝函数？
7. ES5/ES6 的继承除了写法以外还有什么区别？
    1. class相比较于function，不会变量提升，相当于let和var的区别
    2. class 声明内部会启用严格模式。
    3. class 的所有方法（包括静态方法和实例方法）都是不可枚举的。Object.keys()无效
    4. **class 的所有方法**（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有\[\[construct]]，不能使用 new 来调用。
    5. 必须使用 new 调用 class。
    6. class 内部无法重写类名。
10. 8~10 await async promise 事件循环
    ~~~
    async function async1() {
        console.log('async1 start');
        await async2();
        console.log('async1 end');
    }
    // 相当于
    async function async1() {
        console.log('async1 start');
        Promise.resolve(async2()).then(() => {
                console.log('async1 end');
        })
    }
    ~~~
11. 将一个数组扁平化、去重、排序
    ~~~
    var temp= Array.from(new Set(ma.toString().split(','))).sort((a,b)=>(a-b))

    // 或者使用flat
    var temp= ma.flat(Infinity).unique().sort((a,b)=>(a-b))
    ~~~
14. 实现一个new
    ~~~
    var _new=function(fn,...argc){
        // 声明一个对象并链接this
        let obj=Object.create(fn.prototype)
        // 链接参数 指定this
        let result=fn.apply(obj,argc)
        return result instanceof Object ?result:obj
    }
    ~~~
    为什么最后一把要确认实例，有一些函数可以声明返回值
    ~~~
    function _new(fn, ...arg) {
        const obj = Object.create(fn.prototype);
        const ret = fn.apply(obj, arg);
        //return ret instanceof Object ? ret : obj;
        return ret;
    }

    function A(d) {
        this.d = d;
        return 1
    }
    console.log(new A(123));  //{a: 6}
    console.log(_new(A, 123)); //1 
    ~~~
15. http2的多路复用
    1. http1.0 每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。需要使用Connection:keep-alive
    2. http1.1  管道队列机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。（会产生阻塞）TCP 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive。
    3. http2.0 
        1. 多路复用：分割为帧（frame）,并对它们采用二进制格式的编码
        2. 头部压缩：
        3. 支持服务器推送