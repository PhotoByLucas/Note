[原文](https://zhuanlan.zhihu.com/p/146749402)
1. 内存声明的周期

   1. 分配你所需要的内存
   2. 使用分配到的内存(读、写)
   3. 不需要的时候将其释放

2. 两种垃圾回收

   - 调用栈垃圾回收

     举个栗子

     ```
     function test() {
       const a = { name: 'a' };
       function showName() {// ... }
       function getName() {// ... }
       showName();
       getName()
     }
     test();
     ```

     他的执行上下文为
     | showName |执行完后，新的上下文会直接覆盖掉这个上下文|getName|
     |:---:| :---:| :---:|
     | test ||test
     |全局||全局

   - 堆垃圾回收：需使用js垃圾回收器

      - 垃圾回收的步骤
          1. 通过 GC Root 标记空间中的活动对象和非活动对象
          2. 回收非活动对象所占据的内存
          3. 整理内存，减少内存碎片

      - 垃圾回收领域的代际假说
        

        || 新生代|老生代|
        |:---:|:---:| :---:|
        |对象| 大部分的、在内存中存在时间很短的对象，如块级作用域里的变量 |会存在很久的对象，window、dom等|
        |特点|小，回收频繁|大，存活时间长|
        |回收器|副垃圾回收器|主垃圾回收器|

      - 新生代的副回收器策略：采用Scavenge 算法

        1. 将新生代空间**对半**分为对象区域和空闲区域
        2. 当对象区快要被写满时候，进行垃圾标记，将活动对象**复制到空闲区并有序排列**，复制后的空闲区就没有内存碎片
        3. 将对象区和空闲区**角色翻转**
        4. **对象晋升**：经过两次垃圾回收后仍然存在的对象，会被移到老生区
      
      - 老生代的主回收器策略：标记-清除(Mark-Sweep) 标记-整理(Mask-Compact)**todo**
